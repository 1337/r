// Generated by CoffeeScript 1.9.3

import $ from 'jquery';
import _ from 'underscore';
import Backbone from 'backbone';
import Marionette from 'backbone.marionette';
import Views from "./views";

var indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item) return i;
    }
    return -1;
  },
  extend = function (child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }

    function ctor() {
      this.constructor = child;
    }

    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

var Models, Settings, filterRead, settings;
Models = {};
Settings = (function () {
  function Settings() {
  }

  Settings.prototype.get = function (key, defaultValue) {
    var e, thing;
    thing = localStorage.getItem(key);
    if ((!thing) && defaultValue !== void 0) {
      return defaultValue;
    }
    try {
      return JSON.parse(thing);
    } catch (_error) {
      e = _error;
      return thing;
    }
  };

  Settings.prototype.set = function (key, value) {
    return localStorage.setItem(key, JSON.stringify(value));
  };

  Settings.prototype.remove = function (key) {
    return localStorage.removeItem(key);
  };

  return Settings;

})();
settings = Models.settings = new Settings();
Models.filterScore = function (comments, min) {
  if (comments == null) {
    comments = [];
  }
  if (min === -1) {
    return comments;
  } else if (min === void 0) {
    min = settings.get('minscore', 20);
  }
  return _.compact(_.map(comments, function (item) {
    var ref;
    if ((item != null ? (ref = item.data) != null ? ref.score : void 0 : void 0) >= min) {
      return item;
    }
    return void 0;
  }));
};
filterRead = function (posts) {
  var i, len, oldRead, post, postId, read, readPostIds, thing;
  if (posts == null) {
    posts = [];
  }
  read = settings.get('readPosts', []);
  oldRead = _.map(read, _.clone);
  thing = [];
  for (i = 0, len = posts.length; i < len; i++) {
    post = posts[i];
    postId = post.id || post.data.id;
    if (indexOf.call(read, postId) >= 0) {
      post.read = true;
    }
    thing.push(post);
  }
  read.push.apply(read, thing);
  readPostIds = _.filter(_.pluck(_.uniq(read), 'id'));
  readPostIds = _.filter(_.uniq(oldRead.concat(readPostIds)));
  settings.set('readPosts', readPostIds);
  return thing;
};
Models.ReadOnlyModel = (function (superClass) {
  extend(ReadOnlyModel, superClass);

  function ReadOnlyModel() {
    return ReadOnlyModel.__super__.constructor.apply(this, arguments);
  }

  ReadOnlyModel.prototype.sync = function () {
    var method, rest;
    method = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return Backbone.sync.apply(Backbone, ['read'].concat(slice.call(rest)));
  };

  return ReadOnlyModel;

})(Backbone.Model);
Models.Post = (function (superClass) {
  extend(Post, superClass);

  function Post() {
    return Post.__super__.constructor.apply(this, arguments);
  }

  return Post;

})(Models.ReadOnlyModel);
Models.Comment = (function (superClass) {
  extend(Comment, superClass);

  function Comment() {
    return Comment.__super__.constructor.apply(this, arguments);
  }

  Comment.prototype.replies = function () {
    var comments, ref, ref1;
    comments = (ref = this.get('replies')) != null ? (ref1 = ref.data) != null ? ref1.children : void 0 : void 0;
    return Models.Comments(Models.filterScore(comments));
  };

  return Comment;

})(Models.ReadOnlyModel);
Models.Comments = (function (superClass) {
  extend(Comments, superClass);

  function Comments() {
    return Comments.__super__.constructor.apply(this, arguments);
  }

  Comments.prototype.permalink = null;

  Comments.prototype.initialize = function (models, options) {
    if (options == null) {
      options = {};
    }
    return this.permalink = options.permalink || '';
  };

  Comments.prototype.url = function () {
    var url;
    return url = "http://www.reddit.com" + this.permalink + ".json?jsonp=?";
  };

  Comments.prototype.model = function (attrs, options) {
    if (attrs.kind && attrs.data) {
      return new Models.Comment(attrs.data, options);
    }
    return new Models.Comment(attrs, options);
  };

  Comments.prototype.fetch = function (options) {
    var dfr;
    if (options == null) {
      options = {};
    }
    dfr = new $.Deferred();
    _.extend(options, {
      cache: true,
      timeout: 15000
    });
    if (!this.permalink) {
      _.defer(function () {
        return dfr.resolve([]);
      });
      return dfr.promise();
    }
    Backbone.Collection.prototype.fetch.call(this, options).done((function (_this) {
      return function (data) {
        return dfr.resolve(data);
      };
    })(this));
    return dfr.promise();
  };

  Comments.prototype.parse = function (resp) {
    var comments, ref, ref1, root;
    root = resp;
    if (resp.length) {
      root = resp[1];
    }
    comments = (root != null ? (ref = root.data) != null ? ref.children : void 0 : void 0) || (root != null ? (ref1 = root.data) != null ? ref1.replies : void 0 : void 0);
    comments = Models.filterScore(comments);
    return _.sortBy(comments, (function (c) {
      return 1e5 - c.data.score;
    }));
  };

  return Comments;

})(Backbone.Collection);
Models.Listing = (function (superClass) {
  extend(Listing, superClass);

  function Listing() {
    return Listing.__super__.constructor.apply(this, arguments);
  }

  Listing.prototype.initialize = function (models, options) {
    if (options == null) {
      options = {};
    }
    console.debug("Listing initialized with " + options.subreddits);
    return this.subreddits = options.subreddits;
  };

  Listing.prototype.model = function (attrs, options) {
    return new Models.Post(attrs, options);
  };

  Listing.prototype.url = function () {
    var url;
    if (this.subreddits === 'mine') {
      url = "http://www.reddit.com/.json?jsonp=?";
    } else {
      url = "http://www.reddit.com/r/" + this.subreddits + "/.json?jsonp=?";
    }
    if (window.lastPostId) {
      url += '&after=' + window.lastPostId;
    }
    return url;
  };

  Listing.prototype.fetch = function (options) {
    var dfr;
    if (options == null) {
      options = {};
    }
    dfr = new $.Deferred();
    _.extend(options, {
      add: true,
      merge: true,
      remove: false,
      reset: false,
      cache: true,
      timeout: 30000
    });
    Backbone.Collection.prototype.fetch.call(this, options).done(dfr.resolve).fail(function (reason) {
      return dfr.resolve([]);
    });
    return dfr.promise();
  };

  Listing.prototype.parse = function (resp) {
    var posts, ref, ref1, ref2;
    posts = _.pluck(Models.filterScore(resp != null ? (ref = resp.data) != null ? ref.children : void 0 : void 0), 'data');
    if (resp != null ? (ref1 = resp.data) != null ? ref1.after : void 0 : void 0) {
      window.lastPostId = resp != null ? (ref2 = resp.data) != null ? ref2.after : void 0 : void 0;
    } else {
      window.lastPostId = _.last(posts).id;
    }
    _.each(posts, function (post) {
      if (post.subreddit === 'unexpectedjihad') {
        post.subreddit = 'videos';
        return post.score = parseInt(post.score, 10) * 10;
      }
    });
    if (settings.get('filterread')) {
      posts = filterRead(posts);
    }
    return posts;
  };

  return Listing;

})(Backbone.Collection);

export default Models;
